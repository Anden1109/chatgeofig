# -*- coding: utf-8 -*-
"""app_PreguntasV2-Andrea.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13ztCKrwejsFjctgMqpwGBVOhgtlOHce4

## Librerías
"""

!pip install colab-xterm
!pip install langchain
!pip install langchain_ollama
!pip install langchain_community
!pip install langchain_core

"""##Terminal interactiva en Google Colab.
Carga la extensión que habilita la funcionalidad de terminal interactiva en Google Colab.
"""

# Commented out IPython magic to ensure Python compatibility.
# %load_ext colabxterm

"""En la terminal interactiva ejecutar despues de /content#

*1. curl -fsSL https://ollama.com/install.sh | sh

*2. ollama serve & ollama pull llama3
"""

# Commented out IPython magic to ensure Python compatibility.
# %xterm

# Commented out IPython magic to ensure Python compatibility.
# %xterm

import json
from pprint import pprint
from langchain.chains.sql_database.query import create_sql_query_chain
from langchain_community.agent_toolkits import create_sql_agent
from langchain_ollama.chat_models import ChatOllama
from langchain_community.utilities import SQLDatabase
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain.agents import AgentType

import ollama
ollama.list()

url_query = "sqlite:////content/geodata1.db"
db = SQLDatabase.from_uri(url_query, sample_rows_in_table_info=3)
print(db.get_table_info())
llm = ChatOllama(model='llama3:latest', temperature=0.5)
chain = create_sql_agent(db=db, llm=llm, agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True, agent_executor_kwargs={"handle_parsing_errors":True})

def clear_query(query):
    """Answer question using retrieved information as context."""
    prompt = (
        "Given the following text containing a SQL query.\n"
        f"{query}\n"
        "Your job is extract only the sql query from the text. Without modifying it.",
        "No chit chat is needed.",
        "Just answer with the SQL Query"
    )

    response = llm.invoke(prompt)
    return response


def generate_answer(query, question, result):
    """Answer question using retrieved information as context."""
    prompt = (
        "Given the following user question about Geology Thesis papers, corresponding SQL query, "
        "and SQL result, answer the user question always mentioning the Geology Thesis papers as main topic.\n\n"
        "The answer needs to be in Spanish.\n\n"
        f'Question: {question}\n'
        f'SQL Query: {query}\n'
        f'SQL Result: {result}'
    )

    response = llm.invoke(prompt)
    return response.content

question = "tutor con más tesis"

system = """Double check the user's {dialect} query for common mistakes, including:
- Using NOT IN with NULL values
- Using UNION when UNION ALL should have been used
- Using BETWEEN for exclusive ranges
- Data type mismatch in predicates
- Properly quoting identifiers
- Using the correct number of arguments for functions
- Casting to the correct data type
- Using the proper columns for joins
- Using EQUAL (=) operator instead of LIKE operator for text columns

Be very careful to ensure that you always use the LIKE operator and not the EQUAL (=) operator in the WHERE clause for text columns.
If there are any of the above mistakes, rewrite the query.
If there are no mistakes, just reproduce the original query with no further commentary.

Output the final SQL query only."""

prompt = ChatPromptTemplate.from_messages(
    [("system", system), ("human", "{query}")]
).partial(dialect=db.dialect)

validation_chain = prompt | llm | StrOutputParser()

full_chain = {"query": chain} | validation_chain

query = full_chain.invoke(
    {
        "input": question,
        "table_info": db.get_table_info()
    }
)
print("Query: returned: ", query)
query = clear_query(query).content
print("Cleaned Query: returned: ", query)
result = db.run(query)
print("Result: returned: ", result)

generated_answer = generate_answer(question=question, result=result, query=query)
response = {
    "question": question,
    "query": query,
    "answer": generated_answer
}

pprint(response)

question = "tesis del tutor Jarrín Jurado  Jaime Raúl"

system = """Double check the user's {dialect} query for common mistakes, including:
- Using NOT IN with NULL values
- Using UNION when UNION ALL should have been used
- Using BETWEEN for exclusive ranges
- Data type mismatch in predicates
- Properly quoting identifiers
- Using the correct number of arguments for functions
- Casting to the correct data type
- Using the proper columns for joins
- Using EQUAL (=) operator instead of LIKE operator for text columns

Be very careful to ensure that you always use the LIKE operator and not the EQUAL (=) operator in the WHERE clause for text columns.
If there are any of the above mistakes, rewrite the query.
If there are no mistakes, just reproduce the original query with no further commentary.

Output the final SQL query only."""

prompt = ChatPromptTemplate.from_messages(
    [("system", system), ("human", "{query}")]
).partial(dialect=db.dialect)

validation_chain = prompt | llm | StrOutputParser()

full_chain = {"query": chain} | validation_chain

query = full_chain.invoke(
    {
        "input": question,
        "table_info": db.get_table_info()
    }
)
print("Query: returned: ", query)
query = clear_query(query).content
print("Cleaned Query: returned: ", query)
result = db.run(query)
print("Result: returned: ", result)

generated_answer = generate_answer(question=question, result=result, query=query)
response = {
    "question": question,
    "query": query,
    "answer": generated_answer
}

pprint(response)

question = "debería hacer una tesis con tematica geotermia"

system = """Double check the user's {dialect} query for common mistakes, including:
- Using NOT IN with NULL values
- Using UNION when UNION ALL should have been used
- Using BETWEEN for exclusive ranges
- Data type mismatch in predicates
- Properly quoting identifiers
- Using the correct number of arguments for functions
- Casting to the correct data type
- Using the proper columns for joins
- Using EQUAL (=) operator instead of LIKE operator for text columns

Be very careful to ensure that you always use the LIKE operator and not the EQUAL (=) operator in the WHERE clause for text columns.
If there are any of the above mistakes, rewrite the query.
If there are no mistakes, just reproduce the original query with no further commentary.

Output the final SQL query only."""

prompt = ChatPromptTemplate.from_messages(
    [("system", system), ("human", "{query}")]
).partial(dialect=db.dialect)

validation_chain = prompt | llm | StrOutputParser()

full_chain = {"query": chain} | validation_chain

query = full_chain.invoke(
    {
        "input": question,
        "table_info": db.get_table_info()
    }
)
print("Query: returned: ", query)
query = clear_query(query).content
print("Cleaned Query: returned: ", query)
result = db.run(query)
print("Result: returned: ", result)

generated_answer = generate_answer(question=question, result=result, query=query)
response = {
    "question": question,
    "query": query,
    "answer": generated_answer
}

pprint(response)

question = "recomienda tutor para tesis de tematica volcanismo"

system = """Double check the user's {dialect} query for common mistakes, including:
- Using NOT IN with NULL values
- Using UNION when UNION ALL should have been used
- Using BETWEEN for exclusive ranges
- Data type mismatch in predicates
- Properly quoting identifiers
- Using the correct number of arguments for functions
- Casting to the correct data type
- Using the proper columns for joins
- Using EQUAL (=) operator instead of LIKE operator for text columns

Be very careful to ensure that you always use the LIKE operator and not the EQUAL (=) operator in the WHERE clause for text columns.
If there are any of the above mistakes, rewrite the query.
If there are no mistakes, just reproduce the original query with no further commentary.

Output the final SQL query only."""

prompt = ChatPromptTemplate.from_messages(
    [("system", system), ("human", "{query}")]
).partial(dialect=db.dialect)

validation_chain = prompt | llm | StrOutputParser()

full_chain = {"query": chain} | validation_chain

query = full_chain.invoke(
    {
        "input": question,
        "table_info": db.get_table_info()
    }
)
print("Query: returned: ", query)
query = clear_query(query).content
print("Cleaned Query: returned: ", query)
result = db.run(query)
print("Result: returned: ", result)

generated_answer = generate_answer(question=question, result=result, query=query)
response = {
    "question": question,
    "query": query,
    "answer": generated_answer
}

pprint(response)

question = "que tématica puede servir para mi proyecto de titulación"

system = """Double check the user's {dialect} query for common mistakes, including:
- Using NOT IN with NULL values
- Using UNION when UNION ALL should have been used
- Using BETWEEN for exclusive ranges
- Data type mismatch in predicates
- Properly quoting identifiers
- Using the correct number of arguments for functions
- Casting to the correct data type
- Using the proper columns for joins
- Using EQUAL (=) operator instead of LIKE operator for text columns

Be very careful to ensure that you always use the LIKE operator and not the EQUAL (=) operator in the WHERE clause for text columns.
If there are any of the above mistakes, rewrite the query.
If there are no mistakes, just reproduce the original query with no further commentary.

Output the final SQL query only."""

prompt = ChatPromptTemplate.from_messages(
    [("system", system), ("human", "{query}")]
).partial(dialect=db.dialect)

validation_chain = prompt | llm | StrOutputParser()

full_chain = {"query": chain} | validation_chain

query = full_chain.invoke(
    {
        "input": question,
        "table_info": db.get_table_info()
    }
)
print("Query: returned: ", query)
query = clear_query(query).content
print("Cleaned Query: returned: ", query)
result = db.run(query)
print("Result: returned: ", result)

generated_answer = generate_answer(question=question, result=result, query=query)
response = {
    "question": question,
    "query": query,
    "answer": generated_answer
}

pprint(response)

question = "que tesis mencionan la formación Tiyuyacu"

system = """Double check the user's {dialect} query for common mistakes, including:
- Using NOT IN with NULL values
- Using UNION when UNION ALL should have been used
- Using BETWEEN for exclusive ranges
- Data type mismatch in predicates
- Properly quoting identifiers
- Using the correct number of arguments for functions
- Casting to the correct data type
- Using the proper columns for joins
- Using EQUAL (=) operator instead of LIKE operator for text columns

Be very careful to ensure that you always use the LIKE operator and not the EQUAL (=) operator in the WHERE clause for text columns.
If there are any of the above mistakes, rewrite the query.
If there are no mistakes, just reproduce the original query with no further commentary.

Output the final SQL query only."""

prompt = ChatPromptTemplate.from_messages(
    [("system", system), ("human", "{query}")]
).partial(dialect=db.dialect)

validation_chain = prompt | llm | StrOutputParser()

full_chain = {"query": chain} | validation_chain

query = full_chain.invoke(
    {
        "input": question,
        "table_info": db.get_table_info()
    }
)
print("Query: returned: ", query)
query = clear_query(query).content
print("Cleaned Query: returned: ", query)
result = db.run(query)
print("Result: returned: ", result)

generated_answer = generate_answer(question=question, result=result, query=query)
response = {
    "question": question,
    "query": query,
    "answer": generated_answer
}

pprint(response)